<!DOCTYPE html>
<html>
<head>
    <title>Process Initiator</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Mon Nov 10 2014 15:50:02 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Nov 10 2014 15:50:02 GMT-0800 (PST)";
        var CHECKSUM = 53759608133;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.override(Ext.grid.column.Action, {

	buttonText: 'clickme',
    defaultRenderer: function(v, meta, record, rowIdx, colIdx, store, view){
    	var me = this,
            prefix = Ext.baseCSSPrefix,
            scope = me.origScope || me,
            items = me.items,
            len = items.length,
            i = 0,
            item, ret, disabled, tooltip;
 
        // Allow a configured renderer to create initial value (And set the other values in the "metadata" argument!)
        // Assign a new variable here, since if we modify "v" it will also modify the arguments collection, meaning
        // we will pass an incorrect value to getClass/getTip
        ret = Ext.isFunction(me.origRenderer) ? me.origRenderer.apply(scope, arguments) || '' : '';

        meta.tdCls += ' ' + Ext.baseCSSPrefix + 'action-col-cell';
        for (; i < len; i++) {
            item = items[i];

            disabled = item.disabled || (item.isDisabled ? item.isDisabled.call(item.scope || scope, view, rowIdx, colIdx, item, record) : false);
            tooltip = disabled ? null : (item.tooltip || (item.getTip ? item.getTip.apply(item.scope || scope, arguments) : null));

            // Only process the item action setup once.
            if (!item.hasActionConfiguration) {

                // Apply our documented default to all items
                item.stopSelection = me.stopSelection;
                item.disable = Ext.Function.bind(me.disableAction, me, [i], 0);
                item.enable = Ext.Function.bind(me.enableAction, me, [i], 0);
                item.hasActionConfiguration = true;
            }

       ret += '<button class="' + me.buttonCls + ' ' + prefix + 'action-col-' + String(i) + '">' + me.buttonText + '</button>';     
        }
        return ret;    
    },
});
Ext.define('Rally.technicalservices.util.PreferenceSaving',{
    singleton: true,
    logger: new Rally.technicalservices.Logger(),
    PREF_CHUNK_LEN: 30000,
    findKeysAndCreateDate: function(prefix, workspace){
        this.logger.log( "findKeysAndLastModified", prefix );
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store', {
            model: 'Preference',
            fetch: ['Name','CreationDate'],
            limit: 'Infinity',
            context: {workspace: workspace},
            sorters: [ { property: 'Name', direction: 'ASC' } ],
            autoLoad: true,
            filters: [ { property: 'Name', operator: 'contains', value: prefix } ],
            listeners: {
                scope: this, 
                load: function(store,data,success) {
                    this.logger.log('findKeysAndLastModified load', success);
                    if (success) {
                        var pref_keys = {};
                        Ext.each(data, function(rec){
                            pref_keys[rec.get('Name')] = rec.get('CreationDate');
                        });
                        deferred.resolve(pref_keys);
                    } else {
                        deferred.reject();
                    }
                }
            }
        });
        return deferred.promise;        
    },
    saveAsJSON: function(name, object, workspace, appId, filterByUser, project){
        /*
         * This function does the following:
         * 1- Cleans up any existing preferences with this name
         * 2- Saves the object as JSON encoded preference.  
         * If the JSON encoded string is larger than the limit, then
         * the string is broken into pieces and saved.  
         * 3- Saves meta data (.lastupdate)
         * 
         */
        if (appId == undefined) {appId == null;}
        if (project == undefined) {project == null;}
        if (filterByUser == undefined) {filterByUser = false;}
        
        var deferred = Ext.create('Deft.Deferred');
        
        var pref_chunks = this._getJSONChunksFromObject(object);
        var prefs = {};
        Ext.each(pref_chunks, function(chunk, index){
            var pref_name = this._getPrefName(name,index);
            prefs[pref_name] = chunk;
        }, this);
        
        //remove old prefs for name....
        this._cleanPrefs(name, workspace, appId,filterByUser,project).then({
            scope: this,
            success: function(){
                this.logger.log('preferences cleaned, now saving new ones');
                this.save(prefs,workspace, appId,filterByUser,project).then({
                    scope: this,
                    success: function(){
                        deferred.resolve();
                    },
                    failure: function(error){
                        deferred.reject(error);
                    }
                });
            }, 
            failure: function(error){
                this.logger.log('failed to clean out preferences: ', error);
                deferred.reject('failed to clean out preferences: ', error);
            }
        });
        return deferred.promise; 
    },
    _cleanPrefs: function(prefix,workspace, appId,filterByUser,project){
        this.logger.log('_cleanPrefs');
        var deferred = Ext.create('Deft.Deferred');
        this._findPreferencesContainingKey(prefix, workspace).then({
            scope: this,
            success: function(records){
                this.logger.log('Destroying ' + records.length + ' records.');
                if (records.length > 0){
                    this._destroyRecords(records).then({
                        success: function(){
                            deferred.resolve(); 
                        }
                    });
                } else {
                    deferred.resolve();
                }
                
            },
            failure: function(){
                deferred.reject('Failed to find preferences with key ', prefix);
            }
        });
        return deferred.promise;
    },
    _getPrefName: function(name,suffix){
        return name.concat(".").concat(suffix.toString());
    },
    _getJSONChunksFromObject: function(object){
        var pref = Ext.JSON.encode(object);
        var pref_chunks = [];
        
        while (pref.length > this.PREF_CHUNK_LEN){
            pref_chunks.push(pref.substr(0,this.PREF_CHUNK_LEN));
            pref = pref.substr(this.PREF_CHUNK_LEN);
        }
        pref_chunks.push(pref);
        return pref_chunks;
    },
    _getObjectFromJSONChunks: function(json_chunks){
        var json_string = '';
        Ext.Array.each(json_chunks, function(chunk){
            json_string += chunk;
        });
        var obj = Ext.JSON.decode(json_string);
        return obj; 
    },
    _getPrefSuffix: function(name){
        var suffix = name.substr(name.lastIndexOf('.')+1);
        return suffix;  
    },
    _getPrefRoot: function(name){
        var root = name.substr(0, name.lastIndexOf('.'));
        return root;  
    },
    fetchFromJSON: function(name, workspace){
        var deferred = Ext.create('Deft.Deferred');
        //Returns an object retrieved from a JSON encoded preference.
        var json_chunks = new Ext.util.HashMap();
        var last_updated = new Ext.util.HashMap();
        this._findPreferencesContainingKey(name, workspace).then({
            scope:this,
            success: function(data){
                this.logger.log('fetchFromJSON Success.',data);
                //var json_chunks = [];
                //var last_updated = '';
                Ext.each(data, function(rec){
                    var key = this._getPrefRoot(rec.get('Name'));
                    if (!json_chunks.containsKey(key)){
                        json_chunks.add(key,[]);
                        last_updated.add(key,rec.get('CreationDate'));
                    }
                    var idx =  this._getPrefSuffix(rec.get('Name'));
                    var val = rec.get('Value');
                    this.logger.log('key:',key,' idx:',idx);
                    if (!isNaN(idx)){
                        json_chunks.get(key)[idx] = val;
                    } 
                },this);
                
                var objs = new Ext.util.HashMap();
                json_chunks.each(function(key,value,length){
                    objs.add(key,this._getObjectFromJSONChunks(value));
                },this);

                deferred.resolve([objs,last_updated]);
            },
            failure: function(error) {
                deferred.reject(error);
            }
        });
        return deferred.promise; 
    },
    save: function(prefs, workspace, appId, filterByUser, project){
        //Set defaults
        if (appId == undefined) {appId == null;}
        if (project == undefined) {project == null;}
        if (filterByUser == undefined) {filterByUser = false;}
        
        var deferred = Ext.create('Deft.Deferred');
        
        Rally.data.PreferenceManager.update({
            appID: appId,
            project: project,
            workspace: workspace,
            filterByUser: filterByUser,
            settings: prefs,
            scope: this, 
            success: function() {
                this.logger.log('Successfully saved preference:',prefs);
                deferred.resolve();
            },
            failure: function(error){
                this.logger.log('Failed to save preference',prefs, error);
                deferred.reject('Failed to save preferences.  Error:' + error);
            }
        });
        return deferred.promise;
    },
    _findPreferencesContainingKey: function( key_part, workspace ) {
        this.logger.log( "_findPreferencesContainingKey", key_part );
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store', {
            model: 'Preference',
            fetch: ['Name','Value','CreationDate'],
            limit: 'Infinity',
            context: {workspace: workspace},
            sorters: [ { property: 'Name', direction: 'ASC' } ],
            autoLoad: true,
            filters: [ { property: 'Name', operator: 'contains', value: key_part } ],
            listeners: {
                scope: this, 
                load: function(store,data,success) {
                    this.logger.log('_findPreferencesContainingKey load', success);
                    if (success) {
                        deferred.resolve(data);
                    } else {
                        deferred.reject();
                    }
                }
            }
        });
        return deferred.promise;
    },
    _destroyRecords: function(records){
        var promises = [];
        var deferred = Ext.create('Deft.Deferred');
        Ext.each(records,function(rec){
            promises.push(this._destroyRecord(rec));
        }, this);
        Deft.Promise.all(promises).then({
            scope: this,
            success: function(successes){
                deferred.resolve(successes);
                //TODO process to see if everything succeeeded
            }
        });
        return deferred.promise;
        
    },
    _destroyRecord: function(record){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('destroying ' + record.get('Name'));
        record.destroy({
            callback: function(records, operation, success){
                
                deferred.resolve(success); 
            }
        });
        return deferred.promise;
    }
   

});
Ext.define('Rally.technicalservices.ProcessDefinition',{
    logger: new Rally.technicalservices.Logger(),
    processName: '',
    shortName: '',
    /*
     * processType:  Type of process this is enforcing:
     * 		-- new  : creation of a new artifact with rules
     * 		-- edit : editing of an existing artifact with rules
     */
    processType: 'edit', //edit is default
    rallyType: '',  //Required
    /*
     * rallyField:  The field that the processDetail rules belong to.  If this is null, then 
     * this process definition applies to new objects.  
     * 
     */
    rallyField: '',
    /*
     * processDetail - current: The rules for this process
     * 
     *    EXAMPLE (edit):
     *    {
     *    	<triggerValue>: ['requiredfield1','requiredfield2',...] 
     *    }
     *    
     *    EXAMPLE (new):
     *    
     *    {
     *    	 required: ['requiredfield1','requiredfield2',...] 
     *    }
     * 
     */
    processDetail: null, 
    /*
     * processDetail - wannabe: The rules for this process
     * 
     *    EXAMPLE:
     *    {
     *    	type:  presence | inclusion* | exclusion* | format*   (*not implemented yet),
     *      field:  the field that the rule is applied to (e.g. FixedInBuild),
     *      triggerValues: [] Array of values that trigger this rule (e.g. ['Fixed', 'Closed'];  If this is empty, then it applies to all objects
     *    }
     * 
     */
 
    constructor: function(config, jsonObject){
        Ext.apply(this,config);
        if (jsonObject){
        	this. processName = jsonObject.processName;
            this.shortName = jsonObject.shortName;
            this.rallyType = jsonObject.rallyType;
            this.rallyField = jsonObject.rallyField;
            this.processType = jsonObject.processType;
            this.processDetail = jsonObject.processDetail;
        }
    },
    isNew: function(){
    	return (this.processType == 'new');
    },
    /*
     * getProcessFields: returns the fields that are defined in all the rules for the current process
     * 
     */
    getProcessFields: function(){
    	var fields = [];
    	if (this.rallyField){
    		fields.push(this.rallyField);
    	}
    	if (this.processDetail == null) {
    		this.processDetail = {};
    	}
    	Ext.each(Object.keys(this.processDetail), function(pdkey){
			Ext.each(this.processDetail[pdkey], function(pdd){
				fields.push(pdd);
			}, this);
		}, this);
    	return fields; 
    },
    
    /*
     * getTriggeredProcessFields: returns the fields that are triggered by for the current value of the process field
     * 
     */
    getTriggeredProcessFields: function(value){
    	if (this.processDetail == null) {
    		this.processDetail = {};
    	}
    	return this.processDetail[value];
    },
    
    validate: function(detail_field, detail_value, trigger_value){
    	this.logger.log('validate',trigger_value,detail_field,detail_value);
    	var req_fields = [];
    	if (this.processDetail == null) {
    		this.processDetail = {};
    	}
    	
    	if (this.isNew()){
    		return this._validateNew(detail_field,detail_value);
    	}
    	
    	if (Ext.Array.contains(Object.keys(this.processDetail), trigger_value.toString())){
        	req_fields = this.processDetail[trigger_value.toString()];
    	} else {
    		req_fields = this.processDetail.required;
    	}
    	if (Ext.Array.contains(req_fields, detail_field)){
    		if (detail_value && detail_value.toString().length > 0){
    			return {valid: true};  
    		}
    	} else {
			return {valid: true};  
    	}
    	var msg = Ext.String.format("A value for field {0} is required when {1} = {2}.", detail_field, this.rallyField, trigger_value);
		return {valid: false, message: msg};  

    },
    _validateNew: function(detail_field, detail_value){
    	if (this.processDetail == null) {
    		this.processDetail = {};
    	}
    	var req_fields = this.processDetail.required;
    	console.log(req_fields,this.processDetail.required, this.processDetail['required']);
    	if (Ext.Array.contains(req_fields, detail_field)){
    		console.log('array contains ', detail_field, detail_value);
    		if (detail_value && detail_value.length > 0){
    			return {valid: true};  
    		}
    	} else {
			return {valid: true};  
    	}
    	var msg = Ext.String.format("A value for field {0} is required for a new {1}.", detail_field, this.rallyType);
		return {valid: false, message: msg};  
    },
    
/*
 * This is just an example of validations in the model object.  
 * Trying to make the processDetail similiar so that someday we may be able to take
 * advantage of this functionality
 * 
 * validations: [
 *	                {type: 'presence',  field: 'age'},
 *                  {type: 'length',    field: 'name',     min: 2},
 *                  {type: 'inclusion', field: 'gender',   list: ['Male', 'Female']},
 *                  {type: 'exclusion', field: 'username', list: ['Admin', 'Operator']},
 *                  {type: 'format',    field: 'username', matcher: /([a-z]+)[0-9]{2,3}/}
 *               ]
 * 
 */ 
    statics: {
        PROCESS_DEFINITION_PREFIX: 'rally.technicalservices.process-initiator.',
        getProcessDefinitionPrefix: function(type){
        	if (type && type.length > 0 ) {
            	return Rally.technicalservices.ProcessDefinition.PROCESS_DEFINITION_PREFIX  + type.toLowerCase() + '.';
       		
        	} else {
            	return Rally.technicalservices.ProcessDefinition.PROCESS_DEFINITION_PREFIX;
        	}
        }
    }
 
});



Ext.define('Rally.technicalservices.dialog.Process',{
    extend: 'Rally.ui.dialog.Dialog',
    logger: new Rally.technicalservices.Logger(),
    autoShow: true,
    draggable: true,
    width: 400,
    processDefinition: null,
    record: null,
    projectRef: null,
    
    constructor: function(config){
         Ext.apply(this,config);
	     
   	     this.title = this.processDefinition.processName;
         this.items = this._initializeItems();
         this.logger.log('ProcessDefinition dialog constructor', this.title, this.items);
         
         this.callParent(arguments);

         Rally.data.ModelFactory.getModel({
     	    type: this.processDefinition.rallyType,
     	    scope: this,
     	    success: function(model) {
     	    	if (this.processDefinition.processType == 'new'){
         	    	this._createRecord(model);
         	    } else {
         	    	this._fetchRecord(model, this.record.get('ObjectID'));
         	    }
     	    }
     	});
    },
    _fetchRecord: function(model, objectId){
    	model.load(objectId, {
    	    fetch: true,
    	    scope: this,
    	    callback: function(result, operation) {
    	        if(operation.wasSuccessful()) {
    	            this.record = result;
    	            this._addProcessFieldComponent();
    	            this.down('#' + this.processDefinition.rallyField).setValue(this.record.get(this.processDefinition.rallyField));
    	            this._processFieldChanged(this.down('#' + this.processDefinition.rallyField));
    	        }
    	    }
    	});
    },
    _createRecord: function(model){
    	this.logger.log('_createRecord');
    	var record = Ext.create(model, {});
    	this.record = record;
    	this._buildDetailFields(this.processDefinition.getProcessFields());
    },
    
    _initializeItems: function(rec){
  	     var items = [];
  	     items.push({xtype:'container',itemId:'message_box'});
  	     items.push({xtype:'container',itemId:'process-field-container'});
  	     items.push({xtype:'container',itemId: 'detail-container'});
  	     items.push({
             xtype     : 'rallybutton',
             text      : 'Save',
             scope: this,
             handler      : this._save
     	});
  	     items.push( {
             xtype     : 'rallybutton',
             text      : 'Cancel',
             scope: this,
             handler      : this._cancel
         });
  	     return items;
    },

    _addProcessFieldComponent: function(){
    	this.logger.log('_getProcessFieldComponent', this.processDefinition);
    	
    	var field_value = this.record.get(this.processDefinition.rallyField);
    	var field = this.record.getField(this.processDefinition.rallyField)
    	
    	var component = this._getFieldComponent(field, field_value);
    	component['scope'] = this;
    	if (component.xtype == 'rallycheckboxfield'){
        	component['handler'] = this._processFieldChanged;
    	} else { 
        	component['listeners'] = {
                	scope: this,
                	change: this._processFieldChanged
                };
    	}
    	this.down('#process-field-container').add(component);	
    },
    _processFieldChanged: function(ctl, val){
    	this.logger.log('_processFieldChanged',ctl, ctl.getValue());
    	this.down('#detail-container').removeAll();
    	this.down('#message_box').update('');

    	if (ctl.value){
        	var detail_fields = this.processDefinition.getTriggeredProcessFields(ctl.value.toString());
        	this.record.set(this.processDefinition.rallyField,ctl.getValue());
        	
        	Ext.each(detail_fields, function(df){
        		this.logger.log('_processFieldChanged => detail_field', df);
            	var field_obj = this.record.getField(df);
            	var field_val = this.record.get(df);
            	var detail_component = this._getFieldComponent(field_obj, field_val);
        		this.down('#detail-container').add(detail_component);
        	}, this);
    		
    	}
    },
    _buildDetailFields: function(detail_fields){
    	this.down('#detail-container').removeAll();
    	this.down('#message_box').update('');

    	Ext.each(detail_fields, function(df){
    		this.logger.log('_buildDetailFields => detail_field', df);
        	var field_obj = this.record.getField(df);
        	var field_val = this.record.get(df);
        	var detail_component = this._getFieldComponent(field_obj, field_val);
    		this.down('#detail-container').add(detail_component);
    	}, this);
    	
    },
    _getFieldComponent: function(field, val){
    	this.logger.log('_getFieldComponent',field.name, val, field.attributeDefinition.AttributeType);
     
    	var field_name = field.name;
    	if (field.attributeDefinition.Custom){
    		field_name = field_name.replace(/^c\_/,"");
    	}
    	
    	var component = {
       		 itemId: field_name,
       		 fieldLabel: field.displayName,
       		 labelWidth: 150,
       		 minWidth: 400
        };

    	//"BINARY_DATA", "BOOLEAN", "COLLECTION", "DATE", "DECIMAL", "INTEGER", "OBJECT", "QUANTITY", "RATING", "STATE", "STRING", "TEXT", "WEB_LINK", "RAW"
    	switch(field.attributeDefinition.AttributeType){
    		case 'BOOLEAN':  
    			component['xtype'] = 'rallycheckboxfield';
    			break;
    		case 'TEXT':
    			component['xtype'] = 'textareafield';
    			break;
    		case 'STRING':
    		case 'STATE':
    		case 'RATING':
    			console.log(field.attributeDefinition.AttributeType, field.attributeDefinition.AllowedValues);
    			if (field.attributeDefinition.AttributeType == 'RATING' || 
    				field.attributeDefinition.AttributeType == 'STATE' ||
    					field.attributeDefinition.AllowedValues.length > 0){
    				component['xtype'] = 'rallyfieldvaluecombobox';
    				component['model'] = this.processDefinition.rallyType;
    				component['field'] = field.name;
    			} else {
    				component['xtype'] = 'textfield';
    			}
    			break;
    		case 'DATE':
    			component['xtype'] = 'rallydatefield';

    			break;
    		case 'DECIMAL':
    		case 'INTEGER':
    			component['xtype'] = 'rallynumberfield';
    			break;
    		case 'OBJECT':
    			//Release, Iteration, User, Project, artifact links
    			var schema = field.attributeDefinition.SchemaType;
    			console.log('schema',schema);
    			if (schema == 'Iteration') {
    				component['xtype'] = 'rallyiterationcombobox';
    				component['allowNoEntry'] = true;
    				if (val && val._ref){
        				val = val._ref;
    				}
    			} else if (schema == 'Release') {
    				component['xtype'] = 'rallyreleasecombobox';
    				component['allowNoEntry'] = true;

    				if (val && val._ref){
        				val = val._ref;
    				}
    			} else if (schema == 'User') {
    				component['xtype'] = 'rallyusersearchcombobox';
    				component['allowNoEntry'] = true;

    				component['project'] = this.projectRef;
    				if (val && val._ref){
        				val = val._ref;
    				}
    			} else if (schema == 'Project') {
    				component['xtype'] = 'rallyprojectpicker';
    				component['allowNoEntry'] = true;

    				val = this.projectRef;
    				
    			} else if (schema == 'State'){
    				component['xtype'] = 'rallyfieldvaluecombobox';
    				component['model'] = this.processDefinition.rallyType;
    				component['field'] = field.name;
    			}else {
    				//This is a project or artifact link and shouldn't be changed.
    			}
    			break;
    		case 'QUANTITY':
   // 		case 'STATE':
    		case 'WEB_LINK':
    			
    		//These should not be options for this 
    		//case 'RATING':
    		case 'RAW':
    		case 'BINARY_DATA':
    		case 'COLLECTION':
    		default:
    			component['xtype'] = 'container';
    	}
         if (field.attributeDefinition.ReadOnly == true){
        //we need to do something with read only
         }
         this.logger.log('value', val);
        if (val && val.length > 0){
        	component['value'] = val;
        }
        return component;

    },
    _save: function(){
    	//validate
    	this.down('#message_box').update('');
    	var validated = false;
    	if (this.processDefinition.isNew()){
    		validated = this._validateNew();
    	} else {
    		validated = this._validate()
    	}
    	
    	if (validated) {
        	this.record.save();
        	this._cancel();
    	}
    },
    _validate: function(){
    	
    	var val = this.record.get(this.processDefinition.rallyField);
    	var validated = true;
    	Ext.each(this.down('#detail-container').items.items, function(item){
    		var validation_result = this.processDefinition.validate(item.itemId, item.value, val);
    		if (validation_result.valid == false){
    			validated = false;
    			this.down('#message_box').update('<font color="red">' + validation_result.message + '</font>');
    		} else {
        		this.record.set(item.itemId, item.value);
    		}
    	},this);
    	return validated;
    },
    _validateNew: function(){
    	this.logger.log('_validateNew');
    	var validated = true;
    	Ext.each(this.down('#detail-container').items.items, function(item){
    		var validation_result = this.processDefinition.validate(item.itemId, item.value);
    		if (validation_result.valid == false){
    			validated = false;
    			this.down('#message_box').update('<font color="red">' + validation_result.message + '</font>');
    		} else {
        		this.record.set(item.itemId, item.value);
    		}
    	},this);
    	return validated;
    	
    },
     _cancel: function(){
    	this.destroy();
    }
});
Ext.define('Rally.technicalservices.ProcessDriver',{
    logger: new Rally.technicalservices.Logger(),
    projectRef: '',

/*
 * processDefinitions:  Array of Rally.technicalservices.ProcessDefinition objects to define the process for this app
 */
	processDefinitions: [],
/*
 * static_fields:  These fields will always be fetched and displayed regardless of process definition
 */
    static_fields:  ['FormattedID','Name'],  
    
	constructor: function(config){
        Ext.apply(this,config);
    },
/*
 * getDisplayFields:  Returns an array of strings representing fields to display on the grid
 * 
 */
    getDisplayFields: function(){
    	this.logger.log('getDisplayFields');
    	var display_fields = this.static_fields;
    	Ext.each(this.processDefinitions, function(pd){
   	   	 if (!pd.isNew()){
        		display_fields.push(pd.rallyField);
    		}
    	},this);
    	return display_fields;
    },
/*
 * getFetchFields:  Returns an array of strings representing fields to fetch from 
 * the database.  This will include fields that should not be displayed but should
 * be fetched because they are included in the process definition
 * 
 */
    getFetchFields: function(){
    	this.logger.log('getFetchFields');
    	var fetch_fields = this.static_fields;
//    	Ext.each(this.processDefinitions, function(pd){
//    		fetch_fields = (Ext.Array.merge(fetch_fields,pd.getProcessFields()));
//    	}, this);
    	this.logger.log(fetch_fields);
    	return fetch_fields;
    },
/*
 * getColumnConfigurations: Returns an array of column objects to render in the grid.  
 * 
 */
    getColumnConfigurations: function(displayColumns){
    	this.logger.log('getColumnConfigurations');
    	var me = this;
    	
      	var columns = [{ 
            text: 'FormattedID',
            dataIndex: 'FormattedID',
            width: 50,
        },{
            text: 'Name',
            dataIndex: 'Name',
            flex: 1
        }]; 
      	
      	Ext.each(displayColumns, function(dc){
      		console.log(dc.toLowerCase());
      		if (dc.toLowerCase() != 'name' && dc.toLowerCase() != 'formattedid'){
      			columns.push({text: dc, dataIndex: dc});
      		}
      	},this);
      	
      	
    	Ext.each(this.processDefinitions, function(pd){
   	   	 if (!pd.isNew()){
				var process_col = {
						xtype: 'actioncolumn',
						buttonText: pd.shortName,
						buttonCls: 'ts-secondary-button',
						scope: this,
						items: [{
							scope: this,
			                handler: function(grid, row, col) {
			                	me._initiateProcessDialog(grid, row, pd);
			                }
			            }]
					}
				}
				columns.push(process_col);
    	},this);
     return columns;        
    },
    _getArtifactType: function(){
   	 return this.processDefinitions[0].rallyType;
    },
    _getNewArtifactProcessDefinition: function(){
      	 this.logger.log('_getNewArtifactProcessDefinition');
	   	 var newpd = {};

      	 Ext.each(this.processDefinitions, function(pd){
    	   	 console.log(pd);
    	   
      		 if (pd && pd.isNew()){
      			 newpd = pd; 
      		 }
      	 },this);
      	 return newpd;  
       },
     getAddNewText: function(){
    	 var pd = this._getNewArtifactProcessDefinition();
    	 console.log(pd);
    	 if (!_.isEmpty(pd)){
    		 console.log(pd.shortName);
    		 if( pd.shortName.length > 0){
    			 return pd.shortName;
    		 };
    	 }
    	 return '+Add New';
     },

    /*
     * addNew:  Adds a new artifact based on the process definition rules.  If there
     * is no process definition for add new, then it should launch the artifact add new window. 
     */
    addNew: function(){
     	this.logger.log('addNew');
    	
    	var new_pd = this._getNewArtifactProcessDefinition();
    	if (_.isEmpty(new_pd)){
    		//kick off a new object.
    		Rally.nav.Manager.create(this._getArtifactType());

     	} else {
       	   	dlg = Ext.create('Rally.technicalservices.dialog.Process', {
      	   	     processDefinition: new_pd,
      	   	     projectRef: this.projectRef,
      	   	     y: 0
         	 	});
       	   	dlg.show();
    	}
     },
    /*
     * _initiateProcessDialog:  launches the process dialog for the selected process and record. 
     */
    _initiateProcessDialog: function(grid,rowIndex, pd){
    	this.logger.log('_initiateProcessDialog',grid,rowIndex,pd.shortName);
    	var rec = grid.getStore().getAt(rowIndex);
    	dlg = Ext.create('Rally.technicalservices.dialog.Process', {
    	     processDefinition: pd,
    	     projectRef: this.projectRef,
    	     record: rec,
    	     y: 0
    	 });
    	dlg.show();
    }
});

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'settings_box'},
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'button_box', layout: {type:'hbox'}, padding: 10},
        {xtype:'container',itemId:'filter_box', layout: {type:'hbox'}, padding: 10},
        {xtype:'container',itemId:'grid_box', padding: 50},
        {xtype:'tsinfolink'}
    ],
    config: {
        defaultSettings: {
            type: 'Defect',
            displayColumns: 'Name,FormattedID'
        }
    },
    displayFieldBlacklist: ['Changesets','Description','Notes','RevisionHistory','Tags','Attachments',
                            'Tasks','Discussion','DragAndDropRank','LatestDiscussionAgeInMinutes'],
    launch: function() {
    	this._fetchProcessList().then({
    		scope: this,
    		success: function(){
    	        if (this.isExternal()){
    	            this.showSettings();
    	        } else {
    	            this.onSettingsUpdate(this.getSettings());  //(this.config.type,this.config.pageSize,this.config.fetch,this.config.columns);
    	        }        
    	 
    		},
    		failure: function(error){
    			this.logger.log(error);
    			this.processList = [];
    		}
    	}); 
    },

    _fetchProcessList: function(){
    	var deferred = Ext.create('Deft.Deferred');
    	Rally.technicalservices.util.PreferenceSaving.fetchFromJSON(Rally.technicalservices.ProcessDefinition.getProcessDefinitionPrefix(), 
    			this.getContext().getWorkspace()).then({
    				scope: this,
    				success: function(obj){
    					
    	    			 this.processList = obj[0];
    					deferred.resolve();
    				},
    				failure: function(){
    					deferred.reject("Could not load preference keys");
    				}
    			});
    	return deferred.promise;
    },
    _getProcessListStore: function(){
    	var data = [];
    	
    	Ext.each(this.processList.getKeys(), function(key){
    		data.push({'key': key, 'name':this.processList.get(key).processName});
    	},this);
    	return Ext.create('Rally.data.custom.Store',{
    		data: data
    	});
    },
    _configureProcess: function(){
   	    var deferred = Ext.create('Deft.Deferred');
    	dlg = Ext.create('Rally.ui.dialog.Dialog', {
   	   		y: 0,
   	   		modal: true,
   	   		items: [{
   	   			xtype: 'rallybutton',
   	   			text: 'Save',
   	   			handler: function(){
   	   				
   	   			}
   	   		}]
    	});
	   	dlg.show();    
	   	
    },
    getSettingsFields: function(){
    	this.logger.log('getSettingsFields');
    	var store = this._getProcessListStore();

        var filters = Ext.create('Rally.data.wsapi.Filter',{
            property:'Name',
            operator: 'contains',
            value: 'rally.technicalservices.process-initiator.'
        });
        filters = filters.and(Ext.create('Rally.data.wsapi.Filter',{
            property:'Workspace',
            value: this.getContext().getWorkspace()}));
    	
        return [{
                    name: 'type',
                    xtype:'rallycombobox',
                    displayField: 'DisplayName',
                    storeConfig: {
                        model:'TypeDefinition',
                       filters: [{property: 'Restorable',value:true},
                                 {property: 'Creatable', value: true}]
                    },
                    autoExpand: true,
                    fieldLabel: 'Rally Type:',
                    valueField:'TypePath',
            		labelWidth: 100,
            		value: 'Defect',
                    listeners: {
                    	change: function(cb, newValue){
                    		console.log('change',newValue);
                    	}
                    },
                    bubbleEvents: ['change', 'ready'],
                    readyEvent: 'ready'
//                },{
//	                name: 'processes',
//	                xtype: 'rallymultiobjectpicker',
//	                labelWidth: 100,
//	                fieldLabel: 'Processes:',
//	                storeConfig: {
//	                	model: 'preference',
//	                	fetch: ['Name'],
//	                	filters: filters,
//	                	pageSize: 20
//	                 }
        		},{
        			name: 'displayColumns',
        			xtype: 'rallyfieldpicker',
        			fieldLabel: 'Display Columns:',
        			modelTypes: ['Defect'],
        			labelWidth: 100,
        			autoExpand: false,
        			alwaysExpanded: false,
        			fieldBlackList: this.displayFieldBlacklist, 
        			handlesEvents: {
        				change: function(cb, newVal){
        					this.modelTypes = [newVal];
        					this.refreshWithNewContext(this.context);
        				},
        				ready: function(cb){
        					this.modelTypes = [cb.getValue()];
        					this.refreshWithNewContext(this.context);
        				}
        			}
        		}];
    },
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
      },
      //showSettings:  Override
      showSettings: function(options) {      
          var fields = this.getSettingsFields(); 

    	  this._appSettings = Ext.create('Rally.app.AppSettings', Ext.apply({
              fields: this.getSettingsFields(),
              settings: this.getSettings(),
              context: this.getContext(),
              settingsScope: this.settingsScope,
              autoScroll: true
          }, options));

          this._appSettings.on('cancel', this._hideSettings, this);
          this._appSettings.on('save', this._onSettingsSaved, this);
          if (this.isExternal()){
              if (this.down('#settings_box').getComponent(this._appSettings.id)==undefined){
                  this.down('#settings_box').add(this._appSettings);
              }
          } else {
              this.hide();
              this.up().add(this._appSettings);
          }
          return this._appSettings;
      },
      _onSettingsSaved: function(settings){
          Ext.apply(this.settings, settings);
          this._hideSettings();
          this.onSettingsUpdate(settings);
      },
     
      //onSettingsUpdate:  Override
      onSettingsUpdate: function (settings){
          this.logger.log('onSettingsUpdate', settings);
          
//          var process_def_keys = [];
//          if (settings.processDefinitions) {
//              process_def_keys = settings.processDefinitions.split('\n');
//          }
        var process_def_keys = [];
        if (settings.type) {
            Ext.each(this.processList.getKeys(), function(key){
            	if (this.processList.get(key).rallyType.toLowerCase() == settings.type.toLowerCase()){
            		process_def_keys.push(key);
            	}
            },this);
         }
        
          var process_defs = [];
          Ext.each(process_def_keys, function(pdk){
        	  var pd = Ext.create('Rally.technicalservices.ProcessDefinition',{}, this.processList.get(pdk));
        	  process_defs.push(pd);
          },this);
          
          if (process_defs.length == 0){
        	  this.down('#message_box').update('No processes have been defined for this app.  Please use the App Settings to define at least one process.');
        	  return;
          }
          
    	  //Build and save column settings...this means that we need to get the display names and multi-list
          var process_driver = Ext.create('Rally.technicalservices.ProcessDriver',{
          	processDefinitions: process_defs,
          	projectRef: this.getContext().getProjectRef()
          });
          
          /*
           * Add New Button
           */
          var add_new_btn = this.down('#button_box').add({
            	xtype: 'rallybutton',
            	text: process_driver.getAddNewText(),
            	cls: 'primary small',
          });
          add_new_btn.on('click',process_driver.addNew, process_driver);
          
          /*
           * Filter Controls 
           */ 
          var columns = this.settings.displayColumns.toString().split(',');  
          var cb = this.down('#filter_box').add({
        	  xtype: 'rallycombobox',
        	  fieldLabel: 'Filter Results By',
        	  labelAlign: 'right',
        	  itemId: 'filter-property',
        	  allowNoEntry: true,
        	  noEntryText: '-- Select Column --',
        	  store: this._getFilterPropertyStore(columns),
        	  displayField: 'name',
        	  valueField: 'name',
        	  padding: 5,
        	  listeners: {
        		  scope: this,
        		  change: this.addFilterCriteriaBoxes
        	  }        	  
          });
          cb.setValue('Name');

          /*
           * Grid
           */
          var fetch_fields = Ext.Array.merge(process_driver.getFetchFields(), columns);
          var artifact_store =  Ext.create('Rally.data.wsapi.Store', {
              model: settings.type,
              fetch: process_driver.getFetchFields(),
              autoLoad: true,
              pageSize: 500,
          });
          
    	  this.down('#grid_box').add({
              xtype: 'rallygrid',
              store: artifact_store,
              itemId: 'data-grid',
              enableBlockedReasonPopover: false,
              columnCfgs: process_driver.getColumnConfigurations(columns),
              showRowActionsColumn: false,
              enableBulkEdit: false,
              enableRanking: false,
              enableEditing: false,
              showPagingToolbar: true,
              pagingToolbarCfg: {
            	  pageSizes: [20, 50, 200, 500]
              } 
    	  });
      },
      /*
       * Filter Functions
       * 
       */
      _filterGrid: function(){
    	 var prop = this.down('#filter-property').getValue();
    	 var op = this.down('#filter-operator').getValue(); 
    	 var val = this.down('#filter-value').getValue(); 
    	 var f = Ext.create('Rally.data.wsapi.Filter',{
    		    property: prop,
    		    operator: op,
    		    value   : val
    		});
    	  this.down('#data-grid').filter(f,true,true);
      },

      addFilterCriteriaBoxes: function(cb, newValue){
    	  this.logger.log('addFilterCriteriaBoxes', newValue);
          if (this.down('#filter-operator')){this.down('#filter-operator').destroy();}
          if (this.down('#filter-value')){this.down('#filter-value').destroy();}
          if (this.down('#filter-button')){this.down('#filter-button').destroy();}
          if (this.down('#clear-filter-button')){this.down('#clear-filter-button').destroy();}
         
    	  var cbo = this.down('#filter_box').add({
        	  xtype: 'rallycombobox',
        	  itemId: 'filter-operator',
        	  displayField: 'name',
        	  valueField: 'name',
        	  allowNoEntry: true,
        	  noEntryText: '-- Select Operator --',
        	  padding: 5,
        	  store: this._getFilterOperatorStore(newValue)
          });
    	 cbo.setValue('=');
    	  
    	  var filter_value_ctl = this._getFilterValueControl(newValue);
          this.down('#filter_box').add(filter_value_ctl);         
          
          this.down('#filter_box').add({
        	  xtype: 'rallybutton',
        	  itemId: 'filter-button',
        	  scope: this, 
        	  text: 'Filter',
        	  margin: 5,
        	  handler: this._filterGrid
          });
          
          this.down('#filter_box').add({
        	  xtype: 'rallybutton',
        	  itemId: 'clear-filter-button',
        	  scope: this, 
        	  text: 'Clear',
        	  margin: 5,
        	  handler: this._clearGridFilter
          });

      },
      _getFilterValueControl: function(newVal){
    	  var ctl = {
        	  xtype: 'rallytextfield',
        	  padding: 5,
        	  itemId: 'filter-value'
          };
    	  if (newVal && (newVal.toLowerCase() == 'project')){
    		  ctl = {
    				  xtype: 'rallyprojectpicker',
    				  itemId: 'filter-value',
    	        	  padding: 5
    		  };
    	  }
    	  if (newVal && (newVal.toLowerCase() == 'owner' || newVal.toLowerCase() == 'submittedby')){
    		  ctl = {
    			xtype: 'rallyusersearchcombobox',
    			project: this.getContext().getProject(),
				itemId: 'filter-value',
				padding: 5
    		  };
    	  }
    	  return ctl; 
      },
      _clearGridFilter: function(){
    	  this.down('#data-grid').getStore().clearFilter();
    	  this.down('#filter-property').setValue(null);
    	  this.down('#filter-operator').setValue(null);
    	  this.down('#filter-value').setValue('');

      },
      _getFilterPropertyStore: function(columns){
		  	this.logger.log('_getFilterPropertyStore');
		
		  	var data = [];
			Ext.each(columns, function(col){
		        data.push( {'name': col} );
			},this);
			
			var fb_store = Ext.create('Rally.data.custom.Store', {
		        data: data,
		        autoLoad: true
		    });
			return fb_store; 
      },

      _getFilterOperatorStore: function(newVal){
		  	this.logger.log('_getFilterOperatorStore');

		  	var data = [ {'name':'='}, {'name':'contains'}];
		  	if (newVal && (newVal.toLowerCase() == 'owner' || newVal.toLowerCase() == 'submittedby' ||
		  			newVal.toLowerCase() == 'project')){
		  		data = [ {'name':'='}];
		  	}
		  	
			var fb_store = Ext.create('Rally.data.custom.Store', {
		        data: data,
		        autoLoad: true
		    });
			return fb_store; 
      }
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Process Initiator'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.ts-secondary-button {
	color: #00A9E0;
	font-family: NotoSans, Helvetica, Arial;
	background-color: #FFFFFF;
	border:1px solid #00A9E0;
}
.ts-secondary-button:hover {
	color: #00A9E0;
	font-family: NotoSans, Helvetica, Arial;
	background-color: transparent;
	cursor: pointer;
	border:1px solid #00A9E0;

}
    </style>

</head>
<body></body>
</html>